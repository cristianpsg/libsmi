/*
 * smidump.c --
 *
 *      Dump a MIB module conforming to a given format.
 *
 * Copyright (c) 1999 Frank Strauss, Technical University of Braunschweig.
 * Copyright (c) 1999 J. Schoenwaelder, Technical University of Braunschweig.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * @(#) $Id: smidump.c,v 1.48 2000/11/08 18:11:09 strauss Exp $
 */

#include <config.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_GETOPT_H
#include <getopt.h>
#endif
#ifdef HAVE_WIN_H
#include "win.h"
#endif

#include "smi.h"
#include "smidump.h"



/*
 * Driver capability flags which are used to warn about options not
 * understood by a particular output driver.
 */

#define DRIVER_CANT_UNITE	0x02
#define DRIVER_CANT_OUTPUT	0x04


/*
 * The data structure which represents the entry point for an output
 * driver. The ignflags contain the driver capabilities as described
 * above.
 */


typedef struct {
    char *name;				/* Name of the output driver. */
    void (*func) (int, SmiModule **,	/* Output generating function. */
		  int, char *);
    int smiflags;			/* Flags for the SMI parser. */
    int ignflags;			/* Output driver flags ignored. */
    char *descr;			/* Short description. */
} Driver;



static Driver driverTable[] = {
    {
	"SMIng",
	dumpSming,
	0,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"SMIng"
    },
    {
	"SMIv2",
	dumpSmiV2,
	0,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"SMIv2 (RFC 2578, RFC 2579, RFC 2580)"
    },
    {
	"SMIv1",
	dumpSmiV1,
	0,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"SMIv1 (RFC 1155, RFC 1212, RFC 1215)"
    },
    {
	"imports",
	dumpImports,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE,
	"recursive list of all imports"
    },
    {
	"types",
	dumpTypes,
	SMI_FLAG_NODESCR,
	0, /** output ? **/
	"recursive list of all derived types"
    },
    {
	"tree",
	dumpTree,
	SMI_FLAG_NODESCR,
	0, /** output ? **/
	"structure of the OID tree"
    },
    {
	"identifiers",
	dumpIdentifiers,
	SMI_FLAG_NODESCR,
	0, /** output ? **/
	"list of all identifiers"
    },
    {
	"metrics",
	dumpMetrics,
	0,
	0,
	"metrics characterizing MIB modules"
    },
    {
	"mosy",
	dumpMosy,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE,
	"intermediate format generated by the mosy compiler"
    },
    {
	"xml",
	dumpXml,
	0,
	DRIVER_CANT_UNITE, /** output ? **/
	"intermediate SMI XML exchange format"
    },
    {
	"corba",
	dumpCorba,
	0,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"corba IDL interface and OID definitions (JIDM)"
    },
    {
	"cm-dia",
	dumpCMDia,
	SMI_FLAG_NODESCR,
	0, /** unite ? output ? **/
	"reverse engineered conceptual model, dia format"
    },
    {
	"cm-xplain",
	dumpCMXplain,
	SMI_FLAG_NODESCR,
	0, /** output ? **/
	"reverse engineered conceptual model, ASCII format"
    },
    {
	"netsnmp",
	dumpNetSnmp,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE,
	"ANSI C code for the NET SNMP package"
    },
    {
	"jax",
	dumpJax,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"Java AgentX sub-agent classes in separate files"
    },
    {
	"python",
	dumpPython,
	0,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"Python MIB dictionaries"
    },
#if 0
    {
	"sql",
	dumpSql,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"SQL data model definitions"
    },
#endif
#if 0
    {
	"fig-tree",
	dumpFigTree,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"tree graphics in xfig fig format"
    },
    {
	"fig-uml",
	dumpFigUml,
	SMI_FLAG_NODESCR,
	DRIVER_CANT_UNITE | DRIVER_CANT_OUTPUT,
	"UML graphics in xfig fig format"
    },
#endif
    { NULL, NULL, 0, 0, NULL }
};



void *xmalloc(size_t size)
{
    char *m = malloc(size);
    if (! m) {
	fprintf(stderr, "smidump: malloc failed - running out of memory\n");
	exit(1);
    }
    return m;
}



void *xrealloc(void *ptr, size_t size)
{
    char *m = realloc(ptr, size);
    if (! m) {
	fprintf(stderr, "smidump: realloc failed - running out of memory\n");
	exit(1);
    }
    return m;
}



char *xstrdup(const char *s)
{
    char *m = strdup(s);
    if (! m) {
	fprintf(stderr, "smidump: strdup failed - running out of memory\n");
	exit(1);
    }
    return m;
}



void xfree(void *ptr)
{
    free(ptr);
}



static void formats()
{
    Driver *driver = driverTable;
    
    for (driver = driverTable; driver->name; driver++) {
	fprintf(stderr, "  %-12s: %s\n", driver->name,
 		driver->descr ? driver->descr : "...");
    }
}



static void usage()
{
    fprintf(stderr,
	    "Usage: smidump [-Vhsu] [-l <level>] [-c <configfile>] [-f <format>]\n"
	    "               [-p <module>] [-o <name>] <module_or_path>\n"
	    "-V                  show version and license information\n"
	    "-h                  show usage information\n"
	    "-s                  do not generate any comments\n"
	    "-c <configfile>     load a specific configuration file\n"
	    "-p <module>         preload <module>\n"
	    "-l <level>          set maximum level of errors and warnings\n"
	    "-f <format>         use <format> when dumping (default %s)\n"
	    "-o <name>           use <name> when creating names for output files\n"
	    "-u                  print a single united output of all modules\n"
	    "<module_or_path>    name of a MIB module or file path\n\n",
	    driverTable->name);
    fprintf(stderr, "Supported formats are:\n");
    formats();
}



static void version()
{
    printf("smidump " SMI_VERSION_STRING "\n");
}



int
main(argc, argv)
    int argc;
    char *argv[];
{
    char c;
    char *modulename;
    char *output = NULL;
    SmiModule *smiModule;
    int flags, smiflags, i;
    Driver *driver = driverTable;
    SmiModule **modv = NULL;
    int modc = 0;

    for (i = 1; i < argc; i++) if (strstr(argv[i], "-c") == argv[i]) break;
    if (i == argc) 
	smiInit("smidump");
    else
	smiInit(NULL);

    flags = 0;
    while ((c = getopt(argc, argv, "Vhsul:f:p:c:o:")) != -1) {
	switch (c) {
	case 'c':
	    smiReadConfig(optarg, "smiquery");
	    break;
	case 'V':
	    version();
	    return 0;
	case 'h':
	    usage();
	    return 0;
	case 'l':
	    smiSetErrorLevel(atoi(optarg));
	    break;
	case 's':
	    flags |= SMIDUMP_FLAG_SILENT;
	    break;
	case 'p':
	    smiLoadModule(optarg);
	    break;
	case 'u':
	    flags |= SMIDUMP_FLAG_UNITE;
	    break;
	case 'f':
	    for (driver = driverTable; driver->name; driver++) {
		if (strcasecmp(driver->name, optarg) == 0) {
		    break;
		}
	    }
	    if (!driver->name) {
		fprintf(stderr, "smidump: invalid dump format `%s'"
			" - supported formats are:\n", optarg);
		formats();
		exit(1);
	    }
	    break;
	case 'o':
	    output = optarg;
	    break;
	default:
	    usage();
	    exit(1);
	}
    }

    smiflags = smiGetFlags();
    smiflags |= SMI_FLAG_ERRORS;
    smiflags |= driver->smiflags;
    smiSetFlags(smiflags);

    if (flags & SMIDUMP_FLAG_UNITE && driver->ignflags & DRIVER_CANT_UNITE) {
	fprintf(stderr, "smidump: %s format does not support united output:"
		" ignoring -u\n", driver->name);
	flags = (flags & ~SMIDUMP_FLAG_UNITE);
    }

    if (output && driver->ignflags & DRIVER_CANT_OUTPUT) {
	fprintf(stderr, "smidump: %s format does not support output option:"
		" ignoring -o %s\n", driver->name, output);
	output = NULL;
    }

    modv = (SmiModule **) xmalloc((argc - optind) * sizeof(SmiModule *));
    modc = 0;
    
    while (optind < argc) {
	modulename = smiLoadModule(argv[optind]);
	smiModule = modulename ? smiGetModule(modulename) : NULL;
	if (smiModule) {
	    if ((smiModule->conformance) && (smiModule->conformance < 3)) {
		if (! (flags & SMIDUMP_FLAG_SILENT)) {
		    fprintf(stderr,
			    "smidump: module `%s' contains errors, "
			    "expect flawed output\n",
			    argv[optind]);
		}
	    }
	    modv[modc++] = smiModule;
	} else {
	    fprintf(stderr, "smidump: cannot locate module `%s'\n",
		    argv[optind]);
	}
	optind++;
    }

    (driver->func)(modc, modv, flags, output);

    smiExit();

    if (modv) xfree(modv);
    
    return 0;
}
