/*
 * dump-lines.c --
 *
 *      Operations to dump flat line number lists for SMI modules.
 *
 * Copyright (c) 2000 Frank Strauss, Technical University of Braunschweig.
 * Copyright (c) 2000 J. Schoenwaelder, Technical University of Braunschweig.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * @(#) $Id$
 */

#include <config.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "smi.h"
#include "smidump.h"


static int moduleLen = 0;
static int identifierLen = 0;

static int ignoretypes = 0;
static int ignorenodes = 0;




static void fprintNodeLines(FILE *f, int modc, SmiModule **modv)
{
    SmiNode   *smiNode;
    unsigned int i;

    for (i = 0; i < modc; i++) {
	for (smiNode = smiGetFirstNode(modv[i], SMI_NODEKIND_ANY);
	     smiNode;
	     smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
	    if (smiNode->name) {
		fprintf(f, "%*s %*s %d\n",
			-moduleLen, smiGetModulePath(modv[i]),
			-identifierLen, smiNode->name,
			smiGetNodeLine(smiNode));
	    }
	}
    }
}



static void fprintTypeLines(FILE *f, int modc, SmiModule **modv)
{
    SmiType   *smiType;
    int	      i;

    for (i = 0; i < modc; i++) {
	for (smiType = smiGetFirstType(modv[i]);
	     smiType;
	     smiType = smiGetNextType(smiType)) {
	    if (smiType->name) {
		fprintf(f, "%*s %*s %d\n",
			-moduleLen, smiGetModulePath(modv[i]),
			-identifierLen, smiType->name,
			smiGetTypeLine(smiType));
	    }
	}
    }
}



static void dumpLines(int modc, SmiModule **modv, int flags,
			    char *output)
{
    SmiNode   *smiNode;
    int	      i, len;
    FILE      *f = stdout;

    if (output) {
	f = fopen(output, "w");
	if (!f) {
	    fprintf(stderr, "smidump: cannot open %s for writing: ", output);
	    perror(NULL);
	    exit(1);
	}
    }

    for (moduleLen = 0, identifierLen = 0, i = 0; i < modc; i++) {
	len = strlen(smiGetModulePath(modv[i]));
	if (len > moduleLen) moduleLen = len;
	for (smiNode = smiGetFirstNode(modv[i], SMI_NODEKIND_ANY);
	     smiNode;
	     smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
	    if (smiNode->name) {
		len = strlen(smiNode->name);
		if (len > identifierLen) identifierLen = len;
	    }
	}
    }

    if (flags & SMIDUMP_FLAG_UNITE) {

	if (! (flags & SMIDUMP_FLAG_SILENT)) {
	    fprintf(f, "# united list of lines (generated by smidump "
		    SMI_VERSION_STRING ")\n\n");
	}

	if (!ignoretypes) {
	    fprintTypeLines(f, modc, modv);
	}
	
	if (!ignorenodes) {
	    fprintNodeLines(f, modc, modv);
	}

    } else {

	for (i = 0; i < modc; i++) {

	    if (! (flags & SMIDUMP_FLAG_SILENT)) {
		fprintf(f, "# %s list of lines (generated by smidump "
			SMI_VERSION_STRING ")\n\n",
			modv[i]->name);
	    }

	    if (!ignoretypes) {
		fprintTypeLines(f, 1, &(modv[i]));
	    }

	    if (!ignorenodes) {
		fprintNodeLines(f, 1, &(modv[i]));
	    }
	}
    }

    if (output) {
	fclose(f);
    }
}



void initLines()
{
    
    static SmidumpDriverOption opt[] = {
	{ "ignore-types", OPT_FLAG, &ignoretypes, 0,
	  "do not dump types"},
	{ "ignore-nodes", OPT_FLAG, &ignorenodes, 0,
	  "do not dump nodes"},
        { 0, OPT_END, 0, 0 }
    };

    static SmidumpDriver driver = {
	"lines",
	dumpLines,
	SMI_FLAG_NODESCR,
	0,
	"list of all lines",
	opt,
	NULL
    };
    
    smidumpRegisterDriver(&driver);
}
