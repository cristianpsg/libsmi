/*
 * dump-stools.c --
 *
 *      Operations to generate MIB module stubs for the stools package
 *
 * Copyright (c) 2001 J. Schoenwaelder, Technical University of Braunschweig.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * @(#) $Id: dump-stools.c,v 1.2 2001/02/01 10:10:12 schoenw Exp $
 */

/*
 * TODO:
 *	  - generate #defines for deprecated and obsolete objects
 *	  - generate stub codes for the various functions
 *	  - generate type and range checking code
 */

#include <config.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_WIN_H
#include "win.h"
#endif

#include "smi.h"
#include "smidump.h"



static char *getStringTime(time_t t)
{
    static char   s[27];
    struct tm	  *tm;

    tm = gmtime(&t);
    sprintf(s, "%04d-%02d-%02d %02d:%02d",
	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
	    tm->tm_hour, tm->tm_min);
    return s;
}



static void
printTopComment(FILE *f, SmiModule *smiModule)
{
    SmiRevision *smiRevision;
    char *revision = "[unknown]";

    smiRevision = smiGetFirstRevision(smiModule);
    if (smiRevision) {
	revision = getStringTime(smiRevision->date);
    }

    fprintf(f,
	    "/*	\t\t\t\t\t\t-- DO NOT EDIT --\n"
	    " * This file has been generated by smidump\n"
	    " * version " SMI_VERSION_STRING " for the stools package.\n"
	    " *\n"
	    " * Derived from %s revision %s.\n"
	    " *\n * $I" "d$\n"
	    " */\n"
	    "\n", smiModule->name, revision);
}



static char* translate(char *m)
{
    char *s;
    int i;

    s = xstrdup(m);
    for (i = 0; s[i]; i++) {
	if (s[i] == '-') s[i] = '_';
    }
  
    return s;
}



static char* translateUpper(char *m)
{
    char *s;
    int i;

    s = xstrdup(m);
    for (i = 0; s[i]; i++) {
	if (s[i] == '-') s[i] = '_';
	if (islower((int) s[i])) {
	    s[i] = toupper(s[i]);
	}
    }
  
    return s;
}



static char* translateLower(char *m)
{
    char *s;
    int i;

    s = xstrdup(m);
    for (i = 0; s[i]; i++) {
	if (s[i] == '-') s[i] = '_';
	if (isupper((int) s[i])) {
	    s[i] = tolower(s[i]);
	}
    }
  
    return s;
}



static char* translateFileName(char *m)
{
    char *s;
    int i;

    s = xstrdup(m);
    for (i = 0; s[i]; i++) {
	if (s[i] == '_') s[i] = '-';
	if (isupper((int) s[i])) {
	    s[i] = tolower(s[i]);
	}
    }
  
    return s;
}



static FILE * createFile(char *name, char *suffix)
{
    char *fullname;
    FILE *f;

    fullname = xmalloc(strlen(name) + (suffix ? strlen(suffix) : 0) + 2);
    strcpy(fullname, name);
    if (suffix) {
        strcat(fullname, suffix);
    }
    if (!access(fullname, R_OK)) {
        fprintf(stderr, "smidump: %s already exists\n", fullname);
        xfree(fullname);
        return NULL;
    }
    f = fopen(fullname, "w");
    if (!f) {
        fprintf(stderr, "smidump: cannot open %s for writing: ", fullname);
        perror(NULL);
        xfree(fullname);
        exit(1);
    }
    xfree(fullname);
    return f;
}



static int isGroup(SmiNode *smiNode)
{
    SmiNode *childNode;

    if (smiNode->nodekind == SMI_NODEKIND_ROW) {
	return 1;
    }
    
    for (childNode = smiGetFirstChildNode(smiNode);
	 childNode;
	 childNode = smiGetNextChildNode(childNode)) {
	if (childNode->nodekind == SMI_NODEKIND_SCALAR) {
	    return 1;
	}
    }

    return 0;
}



static int isAccessible(SmiNode *groupNode)
{
    SmiNode *smiNode;
    int num = 0;
    
    for (smiNode = smiGetFirstChildNode(groupNode);
	 smiNode;
	 smiNode = smiGetNextChildNode(smiNode)) {
	if ((smiNode->nodekind == SMI_NODEKIND_SCALAR
	     || smiNode->nodekind == SMI_NODEKIND_COLUMN)
	    && (smiNode->access == SMI_ACCESS_READ_ONLY
		|| smiNode->access == SMI_ACCESS_READ_WRITE)) {
	    num++;
	}
    }

    return num;
}



static unsigned int getMinSize(SmiType *smiType)
{
    SmiRange *smiRange;
    SmiType  *parentType;
    unsigned int min = 65535, size;
    
    switch (smiType->basetype) {
    case SMI_BASETYPE_BITS:
	return 0;
    case SMI_BASETYPE_OCTETSTRING:
    case SMI_BASETYPE_OBJECTIDENTIFIER:
	size = 0;
	break;
    default:
	return -1;
    }

    for (smiRange = smiGetFirstRange(smiType);
	 smiRange ; smiRange = smiGetNextRange(smiRange)) {
	if (smiRange->minValue.value.unsigned32 < min) {
	    min = smiRange->minValue.value.unsigned32;
	}
    }
    if (min < 65535 && min > size) {
	size = min;
    }

    parentType = smiGetParentType(smiType);
    if (parentType) {
	unsigned int psize = getMinSize(parentType);
	if (psize > size) {
	    size = psize;
	}
    }

    return size;
}



static unsigned int getMaxSize(SmiType *smiType)
{
    SmiRange *smiRange;
    SmiType  *parentType;
    SmiNamedNumber *nn;
    unsigned int max = 0, size;
    
    switch (smiType->basetype) {
    case SMI_BASETYPE_BITS:
    case SMI_BASETYPE_OCTETSTRING:
	size = 65535;
	break;
    case SMI_BASETYPE_OBJECTIDENTIFIER:
	size = 128;
	break;
    default:
	return -1;
    }

    if (smiType->basetype == SMI_BASETYPE_BITS) {
	for (nn = smiGetFirstNamedNumber(smiType);
	     nn;
	     nn = smiGetNextNamedNumber(nn)) {
	    if (nn->value.value.unsigned32 > max) {
		max = nn->value.value.unsigned32;
	    }
	}
	size = (max / 8) + 1;
	return size;
    }

    for (smiRange = smiGetFirstRange(smiType);
	 smiRange ; smiRange = smiGetNextRange(smiRange)) {
	if (smiRange->maxValue.value.unsigned32 > max) {
	    max = smiRange->maxValue.value.unsigned32;
	}
    }
    if (max > 0 && max < size) {
	size = max;
    }

    parentType = smiGetParentType(smiType);
    if (parentType) {
	unsigned int psize = getMaxSize(parentType);
	if (psize < size) {
	    size = psize;
	}
    }

    return size;
}


static void printHeaderTypedefMember(FILE *f,
				     SmiNode *smiNode, SmiType *smiType)
{
    char *cName;
    unsigned minSize, maxSize;

    cName = translate(smiNode->name);
    switch (smiType->basetype) {
    case SMI_BASETYPE_OBJECTIDENTIFIER:
	maxSize = getMaxSize(smiType);
	minSize = getMinSize(smiType);
	fprintf(f,
		"    guint32  *%s;\n", cName);
	if (maxSize != minSize) {
	    fprintf(f,
		    "    gsize    _%sLength;\n", cName);
	}
	break;
    case SMI_BASETYPE_OCTETSTRING:
    case SMI_BASETYPE_BITS:
	maxSize = getMaxSize(smiType);
	minSize = getMinSize(smiType);
	fprintf(f,
		"    guchar   *%s;\n", cName);
	if (maxSize != minSize) {
	    fprintf(f,
		    "    gsize    _%sLength;\n", cName);
	}
	break;
    case SMI_BASETYPE_ENUM:
    case SMI_BASETYPE_INTEGER32:
	fprintf(f,
		"    gint32   *%s;\n", cName);
	break;
    case SMI_BASETYPE_UNSIGNED32:
	fprintf(f,
		"    guint32  *%s;\n", cName);
	break;
    case SMI_BASETYPE_INTEGER64:
	fprintf(f,
		"    gint64   *%s; \n", cName);
	break;
    case SMI_BASETYPE_UNSIGNED64:
	fprintf(f,
		"    guint64  *%s; \n", cName);
	break;
    default:
	fprintf(f,
		"    /* ?? */  _%s; \n", cName);
	break;
    }
    xfree(cName);
}



static void printHeaderTypedefIndex(FILE *f, SmiNode *smiNode, SmiNode *groupNode)
{
    SmiElement *smiElement;
    SmiNode *iNode, *parentNode;
    SmiType *iType;
    
    for (smiElement = smiGetFirstElement(smiNode);
	 smiElement; smiElement = smiGetNextElement(smiElement)) {
	iNode = smiGetElementNode(smiElement);
	if (iNode) {
	    parentNode = smiGetParentNode(iNode);
	    if (parentNode == groupNode) continue;
	    iType = smiGetNodeType(iNode);
	    if (iType) {
		printHeaderTypedefMember(f, iNode, iType);
	    }
	}
    }
}



static void printHeaderTypedef(FILE *f, SmiModule *smiModule,
			       SmiNode *groupNode)
{
    SmiNode *smiNode, *indexNode;
    SmiType *smiType;
    char    *cModuleName, *cGroupName;

    cModuleName = translateLower(smiModule->name);
    cGroupName = translate(groupNode->name);

    fprintf(f,
	    "/*\n"
	    " * C type definitions for %s::%s.\n"
	    " */\n\n",
	    smiModule->name, groupNode->name);
    
    fprintf(f, "typedef struct %s {\n", cGroupName);

    /*
     * print index objects that are not part of the group
     */

    switch (groupNode->indexkind) {
    case SMI_INDEX_INDEX:
    case SMI_INDEX_REORDER:
	printHeaderTypedefIndex(f, groupNode, groupNode);
	break;
    case SMI_INDEX_EXPAND:	/* TODO: we have to do more work here! */
	break;
    case SMI_INDEX_AUGMENT:
    case SMI_INDEX_SPARSE:
	indexNode = smiGetRelatedNode(groupNode);
	if (indexNode) {
	    printHeaderTypedefIndex(f, indexNode, groupNode);
	}
	break;
    case SMI_INDEX_UNKNOWN:
	break;
    }

	    
    for (smiNode = smiGetFirstChildNode(groupNode);
	 smiNode;
	 smiNode = smiGetNextChildNode(smiNode)) {
	if (smiNode->nodekind & (SMI_NODEKIND_COLUMN | SMI_NODEKIND_SCALAR)
#if 0
	    && (smiNode->access == SMI_ACCESS_READ_ONLY
		|| smiNode->access == SMI_ACCESS_READ_WRITE)
#endif
	    ) {
	    smiType = smiGetNodeType(smiNode);
	    if (! smiType) {
		continue;
	    }
	    printHeaderTypedefMember(f, smiNode, smiType);
	}	    
    }

    fprintf(f, "} %s_t;\n\n", cGroupName);

    fprintf(f, "extern int\n"
	    "%s_get_%s(host_snmp *s, %s_t **%s);\n",
	    cModuleName, cGroupName, cGroupName, cGroupName);
    fprintf(f, "\n");

    xfree(cGroupName);
    xfree(cModuleName);
}



static void printHeaderTypedefs(FILE *f, SmiModule *smiModule)
{
    SmiNode   *smiNode;
    int       cnt = 0;
    
    for (smiNode = smiGetFirstNode(smiModule, SMI_NODEKIND_ANY);
	 smiNode;
	 smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
	if (isGroup(smiNode) && isAccessible(smiNode)) {
	    cnt++;
	    printHeaderTypedef(f, smiModule, smiNode);
	}
    }
    
    if (cnt) {
	fprintf(f, "\n");
    }
}



static void dumpHeader(SmiModule *smiModule, char *baseName)
{
    char *pModuleName;
    FILE *f;
    
    pModuleName = translateUpper(smiModule->name);

    f = createFile(baseName, ".h");
    if (! f) {
	return;
    }

    printTopComment(f, smiModule);
    
    fprintf(f,
	    "#ifndef _%s_H_\n"
	    "#define _%s_H_\n"
	    "\n"
	    "#include \"stools.h\"\n"
	    "\n",
	    pModuleName, pModuleName);

    printHeaderTypedefs(f, smiModule);

    fprintf(f,
	    "#endif /* _%s_H_ */\n",
	    pModuleName);

    fclose(f);
    xfree(pModuleName);
}



static void printOidDefinitions(FILE *f, SmiModule *smiModule)
{
    SmiNode *smiNode;
    char    *cName;
    int     i;
    
    for (smiNode = smiGetFirstNode(smiModule, SMI_NODEKIND_ANY);
	 smiNode;
	 smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
	if (smiNode->nodekind & (SMI_NODEKIND_COLUMN | SMI_NODEKIND_SCALAR)
	    && smiNode->access != SMI_ACCESS_NOTIFY) {
	    cName = translate(smiNode->name);
  	    fprintf(f, "static guint32 %s[] = {", cName);
	    for (i = 0; i < smiNode->oidlen; i++) {
		fprintf(f, "%s%u", i ? ", " : "", smiNode->oid[i]);
	    }
	    fprintf(f, "};\n");
	    xfree(cName);
	}
    }
    fprintf(f, "\n");
}



static void printGetScalarAssignement(FILE *f, SmiNode *groupNode)
{
    SmiNode *smiNode;
    SmiType *smiType;
    char    *cGroupName, *cName;
    unsigned maxSize, minSize;

    cGroupName = translate(groupNode->name);

    for (smiNode = smiGetFirstChildNode(groupNode);
	 smiNode;
	 smiNode = smiGetNextChildNode(smiNode)) {
	if (smiNode->nodekind & (SMI_NODEKIND_COLUMN | SMI_NODEKIND_SCALAR)
	    && (smiNode->access == SMI_ACCESS_READ_ONLY
		|| smiNode->access == SMI_ACCESS_READ_WRITE)) {

	    smiType = smiGetNodeType(smiNode);
	    if (!smiType) {
		continue;
	    }
	    
	    cName = translate(smiNode->name);
	    fprintf(f,
		    "        if (vb->id_len > sizeof(%s)/sizeof(guint32)\n"
		    "            && memcmp(vb->id, %s, sizeof(%s)) == 0) {\n",
		    cName, cName, cName);
	    switch (smiType->basetype) {
	    case SMI_BASETYPE_INTEGER32:
	    case SMI_BASETYPE_ENUM:
		fprintf(f,
			"            (*%s)->%s = (gint32 *) &(vb->syntax.l);\n",
			cGroupName, cName);
		break;
	    case SMI_BASETYPE_UNSIGNED32:
		fprintf(f,
			"            (*%s)->%s = (guint32 *) &(vb->syntax.ul);\n",
			cGroupName, cName);
		break;
	    case SMI_BASETYPE_OCTETSTRING:
	    case SMI_BASETYPE_BITS:
		maxSize = getMaxSize(smiType);
		minSize = getMinSize(smiType);
		if (minSize != maxSize) {
		    fprintf(f,
			    "            (*%s)->_%sLength = vb->syntax_len;\n",
			    cGroupName, cName);
		}
		fprintf(f,
			"            (*%s)->%s = vb->syntax.uc;\n",
			cGroupName, cName);
		break;
	    case SMI_BASETYPE_OBJECTIDENTIFIER:
		fprintf(f,
			"            (*%s)->_%sLength = vb->syntax_len / sizeof(guint32);\n",
			cGroupName, cName);
		fprintf(f,
			"            (*%s)->%s = (guint32 *) vb->syntax.ul;\n",
			cGroupName, cName);
		break;
	    default:
		break;
	    }
	    fprintf(f,
		    "        }\n");
	    xfree(cName);
	}
    }

    xfree(cGroupName);
}



static void printAddVarBind(FILE *f, SmiNode *smiNode, SmiNode *groupNode)
{
    SmiElement *smiElement;
    char *cName;

    if (! (smiNode->nodekind & (SMI_NODEKIND_COLUMN | SMI_NODEKIND_SCALAR))
	&& (smiNode->access != SMI_ACCESS_READ_ONLY
	    && smiNode->access != SMI_ACCESS_READ_WRITE)) {
	return;
    }
    
    /*
     * Suppress all INDEX objects as if they were not-accessible.
     * Perhaps this test needs to be more sophisticated if you have
     * really creative cross table indexing constructions...
     */

    for (smiElement = smiGetFirstElement(groupNode);
	 smiElement; smiElement = smiGetNextElement(smiElement)) {
	if (smiNode == smiGetElementNode(smiElement)) {
	    return;
	}
    }

    cName = translate(smiNode->name);
    fprintf(f,
	    "    g_pdu_add_oid(&in, (gulong *) %s,\n"
	    "                  sizeof(%s)/sizeof(guint32), SNMP_NULL, NULL);\n",
	    cName, cName);
    xfree(cName);
}



static void printGetMethod(FILE *f, SmiModule *smiModule,
			      SmiNode *groupNode)
{
    SmiNode *smiNode;
    char    *cModuleName, *cGroupName;

    cModuleName = translateLower(smiModule->name);
    cGroupName = translate(groupNode->name);

    fprintf(f,
	    "int %s_get_%s(host_snmp *s, %s_t **%s)\n"
	    "{\n"
	    "    GSList *in = NULL, *out = NULL, *elem;\n"

	    "\n",
	    cModuleName, cGroupName, cGroupName, cGroupName);

    for (smiNode = smiGetFirstChildNode(groupNode);
	 smiNode;
	 smiNode = smiGetNextChildNode(smiNode)) {
	printAddVarBind(f, smiNode, groupNode);
    }

    fprintf(f,
	    "\n"
	    "    out = g_sync_getnext(s, in);\n"
	    "    if (! out) {\n"
	    "        return -2;\n"
	    "    }\n"
	    "\n");

    fprintf(f,
	    "    g_slist_free(in);\n"
	    "    in = NULL;\n"
	    "\n");

    /* generate code for error checking and handling */

    fprintf(f,
	    "    *%s = (%s_t *) calloc(1, sizeof(%s_t));\n"
	    "    if (! *%s) {\n"
	    "        return -4;\n"
	    "    }\n"
	    "\n",
	    cGroupName, cGroupName, cGroupName, cGroupName);

    fprintf(f,
	    "    for (elem = out; elem; elem = g_slist_next(elem)) {\n"
	    "        SNMP_OBJECT *vb = (SNMP_OBJECT *) elem->data;\n"
	    "        if (vb->type == SNMP_ENDOFMIBVIEW\n"
            "            || (vb->type == SNMP_NOSUCHOBJECT)\n"
            "            || (vb->type == SNMP_NOSUCHINSTANCE)) {\n"
            "            continue;\n"
	    "        }\n"
	);
    printGetScalarAssignement(f, groupNode);
    fprintf(f,
	    "    }\n"
	    "\n");


#if 0
    if (response->errstat != SNMP_ERR_NOERROR) {
	return -3;
    }

    /* copy to data structures */

    /* cleanup */

#endif

    fprintf(f,
#if 0
	    "    if (response) snmp_free_pdu(response);\n"
#endif
	    "\n"
	    "    return 0;\n"
	    "}\n\n");

    xfree(cGroupName);
    xfree(cModuleName);
}
 



static void printGetMethods(FILE *f, SmiModule *smiModule)
{
    SmiNode   *smiNode;
    int       cnt = 0;
    
    for (smiNode = smiGetFirstNode(smiModule, SMI_NODEKIND_ANY);
	 smiNode;
	 smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
	if (isGroup(smiNode) && isAccessible(smiNode)) {
	    cnt++;
	    printGetMethod(f, smiModule, smiNode);
	}
    }
    
    if (cnt) {
	fprintf(f, "\n");
    }
}



static void dumpStubs(SmiModule *smiModule, char *baseName)
{
    FILE *f;

    f = createFile(baseName, ".c");
    if (! f) {
        return;
    }

    printTopComment(f, smiModule);

    fprintf(f,
	    "#include \"%s.h\"\n"
	    "\n",
	    baseName);
	
    printOidDefinitions(f, smiModule);
    
    printGetMethods(f, smiModule);
    
    fclose(f);
}



static void dumpStools(int modc, SmiModule **modv, int flags, char *output)
{
    char	*baseName;
    int		i;

    if (flags & SMIDUMP_FLAG_UNITE) {
	/* not implemented yet */
    } else {
	for (i = 0; i < modc; i++) {
	    baseName = output ? output : translateFileName(modv[i]->name);
	    dumpHeader(modv[i], baseName);
	    dumpStubs(modv[i], baseName);
	    if (! output) xfree(baseName);
	}
    }

}



void initStools()
{
    static SmidumpDriver driver = {
	"stools",
	dumpStools,
	SMI_FLAG_NODESCR,
	SMIDUMP_DRIVER_CANT_UNITE,
	"ANSI C manager stubs for the stools package",
	NULL,
	NULL
    };

    smidumpRegisterDriver(&driver);
}
