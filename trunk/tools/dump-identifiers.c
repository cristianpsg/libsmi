/*
 * dump-identifiers.c --
 *
 *      Operations to dump flat identifier lists for SMI modules.
 *
 * Copyright (c) 2000 Frank Strauss, Technical University of Braunschweig.
 * Copyright (c) 2000 J. Schoenwaelder, Technical University of Braunschweig.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * @(#) $Id: dump-identifiers.c,v 1.5 2000/08/18 13:20:16 strauss Exp $
 */

#include <config.h>

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "smi.h"
#include "smidump.h"


static Module *moduleList = NULL;
static int moduleLen = 0;
static int identifierLen = 0;



static int pruneSubTree(SmiNode *smiNode)
{
    SmiModule *smiModule;
    SmiNode   *childNode;
    Module    *mPtr;

    if (! smiNode) {
	return 1;
    }

    smiModule = smiGetNodeModule(smiNode);
    for (mPtr = moduleList; mPtr; mPtr = mPtr->nextPtr) {
	if (strcmp(mPtr->smiModule->name, smiModule->name) == 0) {
	    return 0;
	}
    }

    for (childNode = smiGetFirstChildNode(smiNode);
	 childNode;
	 childNode = smiGetNextChildNode(childNode)) {
	if (! pruneSubTree(childNode)) {
	    return 0;
	}
    }
    return 1;
}



static void dumpNodeIdentifiers(SmiNode *smiNode)
{
    SmiModule *smiModule;
    SmiNode   *childNode;
    Module    *mPtr;
    int       i;

    if (smiNode) {

	smiModule = smiGetNodeModule(smiNode);

	if (smiNode->name && smiModule->name) {
	    for (mPtr = moduleList; mPtr; mPtr = mPtr->nextPtr) {
		if (strcmp(mPtr->smiModule->name, smiModule->name) == 0) {
		    break;
		}
	    }
	    if (mPtr) {
		printf("%*s %*s ",
		       -moduleLen, smiModule->name,
		       -identifierLen, smiNode->name);
		for (i = 0; i < smiNode->oidlen; i++) {
		    printf(i ? ".%u" : "%u", smiNode->oid[i]);
		}
		printf("\n");
	    }
	}
	    
	for (childNode = smiGetFirstChildNode(smiNode);
	     childNode;
	     childNode = smiGetNextChildNode(childNode)) {
	    
	    if (! pruneSubTree(childNode)) {
		dumpNodeIdentifiers(childNode);
	    }
	}
    }
}



static void dumpTypeIdentifiers()
{
    SmiModule *smiModule;
    SmiType   *smiType;
    Module    *mPtr;

    for (mPtr = moduleList; mPtr; mPtr = mPtr->nextPtr) {
	smiModule = mPtr->smiModule;
	for (smiType = smiGetFirstType(smiModule);
	     smiType;
	     smiType = smiGetNextType(smiType)) {
	    if (smiType->name) {
		printf("%*s %*s\n",
		       -moduleLen, smiModule->name,
		       -identifierLen, smiType->name);
	    }
	}
    }
}



void dumpIdentifiers(Module *module)
{
    SmiModule *smiModule;
    SmiNode   *smiNode;
    Module    *mPtr, *nextModule = NULL;
    int	      unite, len;

    smiModule = module->smiModule;
    unite = module->flags & SMIDUMP_FLAG_UNITE;

    moduleList = smiModule ? module : module->nextPtr;

    if ((smiModule && !unite) || (!smiModule && unite)) {
	if (! (module->flags & SMIDUMP_FLAG_SILENT)) {
	    printf("# %s list of identifiers (generated by smidump "
		   SMI_VERSION_STRING ")\n\n",
		   unite ? "united" : smiModule->name);
	}

	if (! unite) {
	    nextModule = moduleList->nextPtr;
	    moduleList->nextPtr = NULL;
	}

	for (moduleLen = 0, identifierLen = 0, mPtr = moduleList;
	     mPtr;
	     mPtr = mPtr->nextPtr) {
	    len = strlen(mPtr->smiModule->name);
	    if (len > moduleLen) moduleLen = len;
	    for (smiNode = smiGetFirstNode(mPtr->smiModule, SMI_NODEKIND_ANY);
		 smiNode;
		 smiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {
		if (smiNode->name) {
		    len = strlen(smiNode->name);
		    if (len > identifierLen) identifierLen = len;
		}
	    }
	}

	dumpTypeIdentifiers();
	smiNode = smiGetNode(NULL, "iso");
	if (smiNode) {
	    dumpNodeIdentifiers(smiNode);
	}

	if (! unite) {
	    moduleList->nextPtr = nextModule;
	}
    }
}
