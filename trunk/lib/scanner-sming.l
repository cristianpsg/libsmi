/*
 * scanner-sming.l --
 *
 *      Lexical rules for scanning the SMIng MIB module language.
 *
 * Copyright (c) 1999 Frank Strauss, Technical University of Braunschweig.
 *
 * See the file "COPYING" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * @(#) $Id: scanner-sming.l,v 1.19 2000/02/22 17:11:12 strauss Exp $
 */

%option noyywrap

%{

#include <config.h>
    
#include <stdio.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#include "error.h"
#include "util.h"
#include "parser-sming.h"
#include "parser-sming.tab.h"
#include "scanner-sming.h"



#define thisParser (*(Parser *) parser)



#define MAX_NUMBER		"18446744073709551615" /* max Counter64 */



/*
 * This makes the usual notation when referencing attributes also
 * work with our pure parser code.
 */
#define yylval (*lvalp)


static YY_BUFFER_STATE yybuffer[MAX_LEX_DEPTH];

static int lexDepth = 0; 

 
int
smingEnterLexRecursion(file)
    FILE *file;
{
    if (lexDepth >= MAX_LEX_DEPTH) {
	return (-1);
    }
    yybuffer[lexDepth++] = YY_CURRENT_BUFFER;
    yy_switch_to_buffer(yy_create_buffer(file, YY_BUF_SIZE));
    return (lexDepth);
}


 
void
smingLeaveLexRecursion()
{    
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(yybuffer[--lexDepth]);
}



%}



/*
 * Lex pattern definitions.
 */
delim		([^a-zA-Z0-9-])
lineBreak       ("\n"|"\n\015"|"\015\n")
WSP		(" "|"\t")
VCHAR		([\041-\176])
HTAB		"\t"
SP		" "



%%



 /*
  * Lex rules for comments. Do you use {lineBreak} here because it
  * introduces a trailing context which is (a) slow and (b) causes
  * REJECT to be used.
  */

<INITIAL>"//"({WSP}|{VCHAR})*/"\n" {
}

<INITIAL>"//"({WSP}|{VCHAR})*/"\n\015" {
}

<INITIAL>"//"({WSP}|{VCHAR})*/"\015\n" {
}

 /*
  * Lex rules for some special tokens.
  */

<INITIAL>[\{\}\(\)\;\,\-\.\|] {
    return yytext[0];
}
    
<INITIAL>".." {
    return DOT_DOT;
}

<INITIAL>"::" {
    return COLON_COLON;
}

 /*
  * Lex rules for separators.
  */

<INITIAL>{lineBreak} {
    thisParser.line++;
}

<INITIAL>{WSP} {
}

 /*
  * Lex rules for known keywords.
  */

<INITIAL>module/{delim} {
    yylval.id = yytext;
    return moduleKeyword;
}

<INITIAL>import/{delim} {
    yylval.id = yytext;
    return importKeyword;
}

<INITIAL>revision/{delim} {
    yylval.id = yytext;
    return revisionKeyword;
}

<INITIAL>identity/{delim} {
    yylval.id = yytext;
    return identityKeyword;
}

<INITIAL>oid/{delim} {
    yylval.id = yytext;
    return oidKeyword;
}

<INITIAL>date/{delim} {
    yylval.id = yytext;
    return dateKeyword;
}

<INITIAL>organization/{delim} {
    yylval.id = yytext;
    return organizationKeyword;
}

<INITIAL>contact/{delim} {
    yylval.id = yytext;
    return contactKeyword;
}

<INITIAL>description/{delim} {
    yylval.id = yytext;
    return descriptionKeyword;
}

<INITIAL>reference/{delim} {
    yylval.id = yytext;
    return referenceKeyword;
}

<INITIAL>extension/{delim} {
    yylval.id = yytext;
    return extensionKeyword;
}

<INITIAL>typedef/{delim} {
    yylval.id = yytext;
    return typedefKeyword;
}

<INITIAL>type/{delim} {
    yylval.id = yytext;
    return typeKeyword;
}

<INITIAL>writetype/{delim} {
    yylval.id = yytext;
    return writetypeKeyword;
}

<INITIAL>node/{delim} {
    yylval.id = yytext;
    return nodeKeyword;
}

<INITIAL>scalar/{delim} {
    yylval.id = yytext;
    return scalarKeyword;
}

<INITIAL>table/{delim} {
    yylval.id = yytext;
    return tableKeyword;
}

<INITIAL>column/{delim} {
    yylval.id = yytext;
    return columnKeyword;
}

<INITIAL>row/{delim} {
    yylval.id = yytext;
    return rowKeyword;
}

<INITIAL>notification/{delim} {
    yylval.id = yytext;
    return notificationKeyword;
}

<INITIAL>group/{delim} {
    yylval.id = yytext;
    return groupKeyword;
}

<INITIAL>compliance/{delim} {
    yylval.id = yytext;
    return complianceKeyword;
}

<INITIAL>format/{delim} {
    yylval.id = yytext;
    return formatKeyword;
}

<INITIAL>units/{delim} {
    yylval.id = yytext;
    return unitsKeyword;
}

<INITIAL>status/{delim} {
    yylval.id = yytext;
    return statusKeyword;
}

<INITIAL>access/{delim} {
    yylval.id = yytext;
    return accessKeyword;
}

<INITIAL>default/{delim} {
    yylval.id = yytext;
    return defaultKeyword;
}

<INITIAL>implied/{delim} {
    yylval.id = yytext;
    return impliedKeyword;
}

<INITIAL>index/{delim} {
    yylval.id = yytext;
    return indexKeyword;
}

<INITIAL>augments/{delim} {
    yylval.id = yytext;
    return augmentsKeyword;
}

<INITIAL>reorders/{delim} {
    yylval.id = yytext;
    return reordersKeyword;
}

<INITIAL>sparse/{delim} {
    yylval.id = yytext;
    return sparseKeyword;
}

<INITIAL>expands/{delim} {
    yylval.id = yytext;
    return expandsKeyword;
}

<INITIAL>create/{delim} {
    yylval.id = yytext;
    return createKeyword;
}

<INITIAL>members/{delim} {
    yylval.id = yytext;
    return membersKeyword;
}

<INITIAL>objects/{delim} {
    yylval.id = yytext;
    return objectsKeyword;
}

<INITIAL>mandatory/{delim} {
    yylval.id = yytext;
    return mandatoryKeyword;
}

<INITIAL>optional/{delim} {
    yylval.id = yytext;
    return optionalKeyword;
}

<INITIAL>refine/{delim} {
    yylval.id = yytext;
    return refineKeyword;
}

<INITIAL>abnf/{delim} {
    yylval.id = yytext;
    return abnfKeyword;
}

<INITIAL>OctetString/{delim} {
    yylval.id = yytext;
    return OctetStringKeyword;
}

<INITIAL>ObjectIdentifier/{delim} {
    yylval.id = yytext;
    return ObjectIdentifierKeyword;
}

<INITIAL>Integer32/{delim} {
    yylval.id = yytext;
    return Integer32Keyword;
}

<INITIAL>Unsigned32/{delim} {
    yylval.id = yytext;
    return Unsigned32Keyword;
}

<INITIAL>Integer64/{delim} {
    yylval.id = yytext;
    return Integer64Keyword;
}

<INITIAL>Unsigned64/{delim} {
    yylval.id = yytext;
    return Unsigned64Keyword;
}

<INITIAL>Float32/{delim} {
    yylval.id = yytext;
    return Float32Keyword;
}

<INITIAL>Float64/{delim} {
    yylval.id = yytext;
    return Float64Keyword;
}

<INITIAL>Float128/{delim} {
    yylval.id = yytext;
    return Float128Keyword;
}

<INITIAL>Bits/{delim} {
    yylval.id = yytext;
    return BitsKeyword;
}

<INITIAL>Enumeration/{delim} {
    yylval.id = yytext;
    return EnumerationKeyword;
}

<INITIAL>current/{delim} {
    yylval.id = yytext;
    return currentKeyword;
}

<INITIAL>deprecated/{delim} {
    yylval.id = yytext;
    return deprecatedKeyword;
}

<INITIAL>obsolete/{delim} {
    yylval.id = yytext;
    return obsoleteKeyword;
}

<INITIAL>noaccess/{delim} {
    yylval.id = yytext;
    return noaccessKeyword;
}

<INITIAL>notifyonly/{delim} {
    yylval.id = yytext;
    return notifyonlyKeyword;
}

<INITIAL>readonly/{delim} {
    yylval.id = yytext;
    return readonlyKeyword;
}

<INITIAL>readwrite/{delim} {
    yylval.id = yytext;
    return readwriteKeyword;
}

 /*
  * Lex rules for identifiers.
  */

 /* e.g. module names: REF: draft,p.12-13 */
<INITIAL>[A-Z](-?[a-zA-Z0-9]+)*-? {
    if (yytext[yyleng-1] == '-') {
	printError(parser, ERR_ID_ENDS_IN_HYPHEN, yytext);
    }
    if (yyleng > 64) {
	printError(parser, ERR_UCIDENTIFIER_64, yytext);
    }
    yylval.text = util_strdup(yytext);
    return ucIdentifier;
}

 /* same for lowercase names */
<INITIAL>[a-z](-?[a-zA-Z0-9]+)*-? {
    if (yytext[yyleng-1] == '-') {
	printError(parser, ERR_ID_ENDS_IN_HYPHEN, yytext);
    }
    if (yyleng > 64) {
	printError(parser, ERR_LCIDENTIFIER_64, yytext);
    }
    yylval.text = util_strdup(yytext);
    return lcIdentifier;
}

 /*
  * Lex rules for numbers.
  *
  * NOTE: `-' is a separate token. Hence, there are no negative numbers.
  */

<INITIAL>0+/[0-9] {
    printError(parser, ERR_LEADING_ZEROS);
}

<INITIAL>([1-9][0-9]*|0)/[^0-9] {
    if ((yyleng > sizeof(MAX_NUMBER)-1) ||
	((yyleng == sizeof(MAX_NUMBER)-1) &&
	 (strcmp(yytext, MAX_NUMBER) > 0))) {
	printError(parser, ERR_NUMBER_TOO_LARGE, yytext);
    }
    yylval.text = yytext;
    return decimalNumber;
}

<INITIAL>0x[0-9a-fA-F]+/[^0-9a-fA-F] {
    if (yyleng % 2) {
	printError(parser, ERR_HEX_STRING_MUL2, yytext);
    }
    yylval.text = yytext;
    return hexadecimalNumber;
}
 /*
  * Lex rules for floating point values.
  */

<INITIAL>0.00/{delim} {
    /* TODO */
    yylval.text = yytext;
    return floatValue;
}

 /*
  * Lex rules for textSegments.
  */

<INITIAL>\"[^\"]*\" {
    char *s, *d;		/* the source and destination pointer */
    int column = 0;		/* the current column */
    int newlineflag = 0;	/* we have just passed a newline */
    int cutoffcolumn = 0;	/* cut off white space up to this column */
				/* (computed by caculating the indentation */
				/* of the first column) */

    yytext[yyleng-1] = '\0';
    for (d = yytext, s = yytext+1; s[0]; s++, d++) {

	if ((s[0] == '\n' && s[1] == '\r')	/* newline sequence */
	    || (s[0] == '\r' && s[1] == '\n')) {
	    thisParser.line += 1;
	    d[0] = '\n';
	    s++;
	    newlineflag = 1;
	    column = 0;
	    if (cutoffcolumn < 0) cutoffcolumn = 0;
	} else if (s[0] == '\n') {		/* simple newline */
	    thisParser.line += 1;
	    d[0] = '\n';
	    newlineflag = 1;
	    column = 0;
	    if (cutoffcolumn < 0) cutoffcolumn = 0;
	} else {
	    if (newlineflag && isspace(s[0])) {	/* space after newline */
		if (cutoffcolumn <= 0) {
		    cutoffcolumn -= (s[0] == '\t') ? (8-((column-1) % 8)) : 1;
		}
		column += (s[0] == '\t') ? (8-((column-1) % 8)) : 1;
		if (cutoffcolumn <= 0 || column <= cutoffcolumn) {
		    d--;
		} else {
		    d[0] = s[0];
		    newlineflag = 0;
		}
	    } else {				/* everything else */
		if (! isascii(s[0])) {
		    printError(parser, ERR_ILLEGAL_CHAR_IN_STRING,
			       s[0], (unsigned char) s[0]);
		}
		d[0] = s[0];
		newlineflag = 0;
		if (cutoffcolumn < 0) {
		    cutoffcolumn *= -1;
		}
	    }
	}
    }
    d[0] = '\0';

    yylval.text = yytext;
    return textSegment;
}

 /*
  * Everything else...
  */

. {
    printError(parser, ERR_LEX_UNEXPECTED_CHAR);
}

%%
