/*
 * This CORBA IDL file has been generated by smidump 0.4.2-pre1. Do not edit.
 */

#ifndef _MAU_MIB_IDL_
#define _MAU_MIB_IDL_

#include <ASN1Types.idl>
#include <SNMPMgmt.idl>
#include <IF_MIB.idl>
#include <SNMPv2_SMI.idl>
#include <SNMPv2_TC.idl>

module MAU_MIB {

    typedef IF_MIB::InterfaceIndexType InterfaceIndexType;
    typedef SNMPv2_SMI::Counter32Type Counter32Type;
    typedef SNMPv2_SMI::Counter64Type Counter64Type;
    typedef SNMPv2_SMI::Integer32Type Integer32Type;
    typedef SNMPv2_TC::AutonomousTypeType AutonomousTypeType;
    typedef SNMPv2_TC::TruthValueType TruthValueType;

    const string moduleIdentity = "mauMod";
    const ASN1_ObjectIdentifier mauMod = "::MAU_MIB::mauMod";

    /*
             Management information for 802.3 MAUs.
             
             The following reference is used throughout
             this MIB module:
             
             [IEEE 802.3 Std] refers to:
                IEEE Std 802.3, 2002 Edition: 'IEEE Standard
                for Information technology -
                Telecommunications and information exchange
                between systems - Local and metropolitan
                area networks - Specific requirements -
                Part 3: Carrier sense multiple access with
                collision detection (CSMA/CD) access method
                and physical layer specifications', as
                amended by IEEE Std 802.3ae-2002:
                'Amendment: Media Access Control (MAC)
                Parameters, Physical Layer, and Management
                Parameters for 10 Gb/s Operation', August,
                2002.
             
             Of particular interest is Clause 30, '10Mb/s,
             100Mb/s, 1000Mb/s and 10 Gb/s Management'.
             
             Copyright (C) The Internet Society (2003).  This
             version of this MIB module is part of RFC 3636;
             see the RFC itself for full legal notices.

    LAST-UPDATED:   200309190000Z

    ORGANIZATION:
            "IETF Ethernet Interfaces and Hub MIB
             Working Group"

    CONTACT-INFO:
            "WG E-mail: hubmib@ietf.org
             To subscribe: hubmib-request@ietf.org
                    Chair: Dan Romascanu
                   Postal: Avaya Inc.
                           Atidim Technology Park, Bldg. 3
                           Tel Aviv 61131
                           Israel
                      Tel: +972 3 645 8414
                   E-mail: dromasca@avaya.com
             
             
             
                   Editor: John Flick
                   Postal: Hewlett-Packard Company
                           8000 Foothills Blvd. M/S 5557
                           Roseville, CA 95747-5557
                           USA
                      Tel: +1 916 785 4018
                      Fax: +1 916 785 1199
                   E-mail: johnf@rose.hp.com"

    REVISION:       "200309190000Z"
    REVISION-DESCRIPTION:
            "Updated to include support for 10 Gb/s MAUs.
             This resulted in the following revisions:
             - Added OBJECT-IDENTITY definitions for
               10 gigabit MAU types
             - Added fiberLC jack type to JackType TC
             - Extended ifMauTypeListBits with bits for
               the 10 gigabit MAU types
             - Added enumerations to ifMauMediaAvailable,
               and updated its DESCRIPTION to reflect
               behaviour at 10 Gb/s
             - Added 64-bit version of ifMauFalseCarriers
               and added mauIfGrpHCStats object group to
             
             
             
               contain the new object
             - Deprecated mauModIfCompl2 and replaced it
               with mauModIfCompl3, which includes the new
               object group
             
              This version published as RFC 3636."

    REVISION:       "199908240400Z"
    REVISION-DESCRIPTION:
            "This version published as RFC 2668.  Updated
             to include support for 1000 Mb/sec
             MAUs and flow control negotiation."

    REVISION:       "199710310000Z"
    REVISION-DESCRIPTION:
            "Version published as RFC 2239."

    REVISION:       "199309300000Z"
    REVISION-DESCRIPTION:
            "Initial version, published as RFC 1515."

    */

    /*
             Common enumeration values for repeater
             and interface MAU jack types.
    */
    typedef ASN1_Integer JackTypeType; 
    const JackTypeType JackTypeType_other = 1;
    const JackTypeType JackTypeType_rj45 = 2;
    const JackTypeType JackTypeType_rj45S = 3;
    const JackTypeType JackTypeType_db9 = 4;
    const JackTypeType JackTypeType_bnc = 5;
    const JackTypeType JackTypeType_fAUI = 6;
    const JackTypeType JackTypeType_mAUI = 7;
    const JackTypeType JackTypeType_fiberSC = 8;
    const JackTypeType JackTypeType_fiberMIC = 9;
    const JackTypeType JackTypeType_fiberST = 10;
    const JackTypeType JackTypeType_telco = 11;
    const JackTypeType JackTypeType_mtrj = 12;
    const JackTypeType JackTypeType_hssdc = 13;
    const JackTypeType JackTypeType_fiberLC = 14;
    const string JackTypeType_NameNumberList = "other (1) , rj45 (2) , rj45S (3) , db9 (4) , bnc (5) , fAUI (6) , mAUI (7) , fiberSC (8) , fiberMIC (9) , fiberST (10) , telco (11) , mtrj (12) , hssdc (13) , fiberLC (14)";

    typedef ASN1_Integer RpMauGroupIndexType; 

    typedef ASN1_Integer RpMauPortIndexType; 

    typedef ASN1_Integer RpMauIndexType; 

    typedef ASN1_Integer RpMauStatusType; 
    const RpMauStatusType RpMauStatusType_other = 1;
    const RpMauStatusType RpMauStatusType_unknown = 2;
    const RpMauStatusType RpMauStatusType_operational = 3;
    const RpMauStatusType RpMauStatusType_standby = 4;
    const RpMauStatusType RpMauStatusType_shutdown = 5;
    const RpMauStatusType RpMauStatusType_reset = 6;
    const string RpMauStatusType_NameNumberList = "other (1) , unknown (2) , operational (3) , standby (4) , shutdown (5) , reset (6)";

    typedef ASN1_Integer RpMauMediaAvailableType; 
    const RpMauMediaAvailableType RpMauMediaAvailableType_other = 1;
    const RpMauMediaAvailableType RpMauMediaAvailableType_unknown = 2;
    const RpMauMediaAvailableType RpMauMediaAvailableType_available = 3;
    const RpMauMediaAvailableType RpMauMediaAvailableType_notAvailable = 4;
    const RpMauMediaAvailableType RpMauMediaAvailableType_remoteFault = 5;
    const RpMauMediaAvailableType RpMauMediaAvailableType_invalidSignal = 6;
    const RpMauMediaAvailableType RpMauMediaAvailableType_remoteJabber = 7;
    const RpMauMediaAvailableType RpMauMediaAvailableType_remoteLinkLoss = 8;
    const RpMauMediaAvailableType RpMauMediaAvailableType_remoteTest = 9;
    const RpMauMediaAvailableType RpMauMediaAvailableType_offline = 10;
    const RpMauMediaAvailableType RpMauMediaAvailableType_autoNegError = 11;
    const string RpMauMediaAvailableType_NameNumberList = "other (1) , unknown (2) , available (3) , notAvailable (4) , remoteFault (5) , invalidSignal (6) , remoteJabber (7) , remoteLinkLoss (8) , remoteTest (9) , offline (10) , autoNegError (11)";

    typedef ASN1_Integer RpMauJabberStateType; 
    const RpMauJabberStateType RpMauJabberStateType_other = 1;
    const RpMauJabberStateType RpMauJabberStateType_unknown = 2;
    const RpMauJabberStateType RpMauJabberStateType_noJabber = 3;
    const RpMauJabberStateType RpMauJabberStateType_jabbering = 4;
    const string RpMauJabberStateType_NameNumberList = "other (1) , unknown (2) , noJabber (3) , jabbering (4)";

    typedef ASN1_Integer RpJackIndexType; 

    typedef ASN1_Integer IfMauIndexType; 

    typedef ASN1_Integer IfMauStatusType; 
    const IfMauStatusType IfMauStatusType_other = 1;
    const IfMauStatusType IfMauStatusType_unknown = 2;
    const IfMauStatusType IfMauStatusType_operational = 3;
    const IfMauStatusType IfMauStatusType_standby = 4;
    const IfMauStatusType IfMauStatusType_shutdown = 5;
    const IfMauStatusType IfMauStatusType_reset = 6;
    const string IfMauStatusType_NameNumberList = "other (1) , unknown (2) , operational (3) , standby (4) , shutdown (5) , reset (6)";

    typedef ASN1_Integer IfMauMediaAvailableType; 
    const IfMauMediaAvailableType IfMauMediaAvailableType_other = 1;
    const IfMauMediaAvailableType IfMauMediaAvailableType_unknown = 2;
    const IfMauMediaAvailableType IfMauMediaAvailableType_available = 3;
    const IfMauMediaAvailableType IfMauMediaAvailableType_notAvailable = 4;
    const IfMauMediaAvailableType IfMauMediaAvailableType_remoteFault = 5;
    const IfMauMediaAvailableType IfMauMediaAvailableType_invalidSignal = 6;
    const IfMauMediaAvailableType IfMauMediaAvailableType_remoteJabber = 7;
    const IfMauMediaAvailableType IfMauMediaAvailableType_remoteLinkLoss = 8;
    const IfMauMediaAvailableType IfMauMediaAvailableType_remoteTest = 9;
    const IfMauMediaAvailableType IfMauMediaAvailableType_offline = 10;
    const IfMauMediaAvailableType IfMauMediaAvailableType_autoNegError = 11;
    const IfMauMediaAvailableType IfMauMediaAvailableType_pmdLinkFault = 12;
    const IfMauMediaAvailableType IfMauMediaAvailableType_wisFrameLoss = 13;
    const IfMauMediaAvailableType IfMauMediaAvailableType_wisSignalLoss = 14;
    const IfMauMediaAvailableType IfMauMediaAvailableType_pcsLinkFault = 15;
    const IfMauMediaAvailableType IfMauMediaAvailableType_excessiveBER = 16;
    const IfMauMediaAvailableType IfMauMediaAvailableType_dxsLinkFault = 17;
    const IfMauMediaAvailableType IfMauMediaAvailableType_pxsLinkFault = 18;
    const string IfMauMediaAvailableType_NameNumberList = "other (1) , unknown (2) , available (3) , notAvailable (4) , remoteFault (5) , invalidSignal (6) , remoteJabber (7) , remoteLinkLoss (8) , remoteTest (9) , offline (10) , autoNegError (11) , pmdLinkFault (12) , wisFrameLoss (13) , wisSignalLoss (14) , pcsLinkFault (15) , excessiveBER (16) , dxsLinkFault (17) , pxsLinkFault (18)";

    typedef ASN1_Integer IfMauJabberStateType; 
    const IfMauJabberStateType IfMauJabberStateType_other = 1;
    const IfMauJabberStateType IfMauJabberStateType_unknown = 2;
    const IfMauJabberStateType IfMauJabberStateType_noJabber = 3;
    const IfMauJabberStateType IfMauJabberStateType_jabbering = 4;
    const string IfMauJabberStateType_NameNumberList = "other (1) , unknown (2) , noJabber (3) , jabbering (4)";

    typedef ASN1_OctetString IfMauTypeListBitsType; 

    typedef ASN1_Integer IfJackIndexType; 

    typedef ASN1_Integer IfMauAutoNegAdminStatusType; 
    const IfMauAutoNegAdminStatusType IfMauAutoNegAdminStatusType_enabled = 1;
    const IfMauAutoNegAdminStatusType IfMauAutoNegAdminStatusType_disabled = 2;
    const string IfMauAutoNegAdminStatusType_NameNumberList = "enabled (1) , disabled (2)";

    typedef ASN1_Integer IfMauAutoNegRemoteSignalingType; 
    const IfMauAutoNegRemoteSignalingType IfMauAutoNegRemoteSignalingType_detected = 1;
    const IfMauAutoNegRemoteSignalingType IfMauAutoNegRemoteSignalingType_notdetected = 2;
    const string IfMauAutoNegRemoteSignalingType_NameNumberList = "detected (1) , notdetected (2)";

    typedef ASN1_Integer IfMauAutoNegConfigType; 
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_other = 1;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_configuring = 2;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_complete = 3;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_disabled = 4;
    const IfMauAutoNegConfigType IfMauAutoNegConfigType_parallelDetectFail = 5;
    const string IfMauAutoNegConfigType_NameNumberList = "other (1) , configuring (2) , complete (3) , disabled (4) , parallelDetectFail (5)";

    typedef ASN1_Integer IfMauAutoNegRestartType; 
    const IfMauAutoNegRestartType IfMauAutoNegRestartType_restart = 1;
    const IfMauAutoNegRestartType IfMauAutoNegRestartType_norestart = 2;
    const string IfMauAutoNegRestartType_NameNumberList = "restart (1) , norestart (2)";

    typedef ASN1_OctetString IfMauAutoNegCapabilityBitsType; 

    typedef ASN1_OctetString IfMauAutoNegCapAdvertisedBitsType; 

    typedef ASN1_OctetString IfMauAutoNegCapReceivedBitsType; 

    typedef ASN1_Integer IfMauAutoNegRemoteFaultAdvertisedType; 
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_noError = 1;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_offline = 2;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_linkFailure = 3;
    const IfMauAutoNegRemoteFaultAdvertisedType IfMauAutoNegRemoteFaultAdvertisedType_autoNegError = 4;
    const string IfMauAutoNegRemoteFaultAdvertisedType_NameNumberList = "noError (1) , offline (2) , linkFailure (3) , autoNegError (4)";

    typedef ASN1_Integer IfMauAutoNegRemoteFaultReceivedType; 
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_noError = 1;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_offline = 2;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_linkFailure = 3;
    const IfMauAutoNegRemoteFaultReceivedType IfMauAutoNegRemoteFaultReceivedType_autoNegError = 4;
    const string IfMauAutoNegRemoteFaultReceivedType_NameNumberList = "noError (1) , offline (2) , linkFailure (3) , autoNegError (4)";

    interface dot3RpMauBasicGroup : SNMPMgmt::SmiEntry {

        /*
             Table of descriptive and status information
             about the MAU(s) attached to the ports of a
             repeater.
        */
        SNMPMgmt::SmiTableIterator get_rpMauTable();

        /*
             Information about the external jacks attached
             to MAUs attached to the ports of a repeater.
        */
        SNMPMgmt::SmiTableIterator get_rpJackTable();
    };


    /*
             An entry in the table, containing information
             about a single MAU.
    */
    interface rpMauEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "rpMauGroupIndex rpMauPortIndex rpMauIndex";

        /*
             This variable uniquely identifies the group
             containing the port to which the MAU described
             by this entry is connected.
             
             Note:  In practice, a group will generally be
             a field-replaceable unit (i.e., module, card,
             or board) that can fit in the physical system
             enclosure, and the group number will correspond
             to a number marked on the physical enclosure.
             
             The group denoted by a particular value of this
             object is the same as the group denoted by the
             same value of rptrGroupIndex.
        REFERENCE:
            "Reference RFC 2108, rptrGroupIndex."

        */
        readonly attribute RpMauGroupIndexType rpMauGroupIndex;

        /*
             This variable uniquely identifies the repeater
             port within group rpMauGroupIndex to which the
             MAU described by this entry is connected.
        REFERENCE:
            "Reference RFC 2108, rptrPortIndex."

        */
        readonly attribute RpMauPortIndexType rpMauPortIndex;

        /*
             This variable uniquely identifies the MAU
             described by this entry from among other
             MAUs connected to the same port
             (rpMauPortIndex).
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.1, aMAUID."

        */
        readonly attribute RpMauIndexType rpMauIndex;

        /*
             This object identifies the MAU type.  Values for
             standard IEEE 802.3 MAU types are defined above.
             If the MAU type is unknown, the object identifier
             
             unknownMauType OBJECT IDENTIFIER ::= { 0 0 }
             
             is returned.  Note that unknownMauType is a
             syntactically valid object identifier, and any
             conformant implementation of ASN.1 and the BER
             must be able to generate and recognize this
             value.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.2, aMAUType."

        */
        readonly attribute AutonomousTypeType rpMauType;

        /*
             The current state of the MAU.  This object MAY
             be implemented as a read-only object by those
             agents and MAUs that do not implement software
             control of the MAU state.  Some agents may not
             support setting the value of this object to some
             of the enumerated values.
             
             The value other(1) is returned if the MAU is in
             a state other than one of the states 2 through
             6.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             A MAU in the operational(3) state is fully
             functional, operates, and passes signals to its
             attached DTE or repeater port in accordance to
             its specification.
             
             A MAU in standby(4) state forces DI and CI to
             idle and the media transmitter to idle or fault,
             if supported.  Standby(4) mode only applies to
             link type MAUs.  The state of
             rpMauMediaAvailable is unaffected.
             
             A MAU in shutdown(5) state assumes the same
             condition on DI, CI, and the media transmitter
             as though it were powered down or not connected.
             The MAU MAY return other(1) value for the
             rpMauJabberState and rpMauMediaAvailable objects
             when it is in this state.  For an AUI, this
             state will remove power from the AUI.
             
             Setting this variable to the value reset(6)
             resets the MAU in the same manner as a
             power-off, power-on cycle of at least one-half
             second would.  The agent is not required to
             return the value reset (6).
             
             Setting this variable to the value
             operational(3), standby(4), or shutdown(5)
             causes the MAU to assume the respective state
             except that setting a mixing-type MAU or an AUI
             to standby(4) will cause the MAU to enter the
             
             
             
             shutdown state.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.7, aMAUAdminState,
             30.5.1.2.2, acMAUAdminControl, and 30.5.1.2.1,
             acResetMAU."

        */
        attribute RpMauStatusType rpMauStatus;

        /*
             If the MAU is a link or fiber type (FOIRL,
             10BASE-T, 10BASE-F) then this is equivalent to
             the link test fail state/low light function.
             For an AUI or a coax (including broadband) MAU
             this indicates whether or not loopback is
             detected on the DI circuit.  The value of this
             attribute persists between packets for MAU types
             AUI, 10BASE5, 10BASE2, 10BROAD36, and 10BASE-FP.
             
             The value other(1) is returned if the
             mediaAvailable state is not one of 2 through 11.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.  At power-up or following a
             reset, the value of this attribute will be
             unknown for AUI, coax, and 10BASE-FP MAUs.  For
             these MAUs loopback will be tested on each
             transmission during which no collision is
             detected.  If DI is receiving input when DO
             returns to IDL after a transmission and there
             has been no collision during the transmission
             then loopback will be detected.  The value of
             this attribute will only change during
             non-collided transmissions for AUI, coax, and
             10BASE-FP MAUs.
             
             
             
             For 100Mbps and 1000Mbps MAUs, the enumerations
             match the states within the respective link
             integrity state diagrams, fig 32-16, 23-12 and
             24-15 of sections 32, 23 and 24 of [IEEE802.3].
             Any MAU which implements management of
             auto-negotiation will map remote fault
             indication to remote fault.
             
             The value available(3) indicates that the link,
             light, or loopback is normal.  The value
             notAvailable(4) indicates link loss, low light,
             or no loopback.
             
             The value remoteFault(5) indicates that a fault
             has been detected at the remote end of the link.
             This value applies to 10BASE-FB, 100BASE-T4 Far
             End Fault Indication and non-specified remote
             faults from a system running auto-negotiation.
             The values remoteJabber(7), remoteLinkLoss(8),
             and remoteTest(9) SHOULD be used instead of
             remoteFault(5) where the reason for remote fault
             is identified in the remote signaling protocol.
             
             The value invalidSignal(6) indicates that an
             invalid signal has been received from the other
             end of the link.  invalidSignal(6) applies only
             to MAUs of type 10BASE-FB.
             
             Where an IEEE Std 802.3-2002 clause 22 MII
             is present, a logic one in the remote fault bit
             (reference section 22.2.4.2.8 of that document)
             maps to the value remoteFault(5), and a logic
             zero in the link status bit (reference section
             22.2.4.2.10 of that document) maps to the value
             notAvailable(4).  The value notAvailable(4)
             takes precedence over the value remoteFault(5).
             
             Any MAU that implements management of clause 37
             Auto-Negotiation will map the received Remote
             Fault (RF1 and RF2) bit values for Offline to
             offline(10), Link Failure to remoteFault(5) and
             Auto-Negotiation Error to autoNegError(11).
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.4, aMediaAvailable."

        */
        readonly attribute RpMauMediaAvailableType rpMauMediaAvailable;

        /*
             A count of the number of times that
             rpMauMediaAvailable for this MAU instance leaves
             the state available(3).
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.5,
             aLoseMediaCounter.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauMediaAvailableStateExits;

        /*
             The value other(1) is returned if the jabber
             state is not 2, 3, or 4.  The agent MUST always
             return other(1) for MAU type dot3MauTypeAUI.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             If the MAU is not jabbering the agent returns
             noJabber(3).  This is the 'normal' state.
             
             If the MAU is in jabber state the agent returns
             the jabbering(4) value.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.6,
             aJabber.jabberFlag."

        */
        readonly attribute RpMauJabberStateType rpMauJabberState;

        /*
             A count of the number of times that
             mauJabberState for this MAU instance enters the
             state jabbering(4).  For MAUs of type
             
             
             
             dot3MauTypeAUI, dot3MauType100BaseT4,
             dot3MauType100BaseTX, dot3MauType100BaseFX and
             all 1000Mbps types, this counter will always
             indicate zero.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.6,
             aJabber.jabberCounter.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauJabberingStateEnters;

        /*
             A count of the number of false carrier events
             during IDLE in 100BASE-X links.  This counter
             does not increment at the symbol rate.  It can
             increment after a valid carrier completion at a
             maximum rate of once per 100 ms until the next
             carrier event.
             
             This counter increments only for MAUs of type
             dot3MauType100BaseT4, dot3MauType100BaseTX, and
             dot3MauType100BaseFX and all 1000Mbps types.
             
             For all other MAU types, this counter will
             always indicate zero.
             
             The approximate minimum time for rollover of
             this counter is 7.4 hours.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of rptrMonitorPortLastChange.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.10, aFalseCarriers.
             RFC 2108, rptrMonitorPortLastChange"

        */
        readonly attribute Counter32Type rpMauFalseCarriers;
    };


    /*
             An entry in the table, containing information
             about a particular jack.
    */
    interface rpJackEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "rpMauGroupIndex rpMauPortIndex rpMauIndex rpJackIndex";

        /*
             The jack connector type, as it appears on the
             outside of the system.
        */
        readonly attribute JackTypeType rpJackType;
    };

    interface dot3IfMauBasicGroup : SNMPMgmt::SmiEntry {

        /*
             Table of descriptive and status information
             about MAU(s) attached to an interface.
        */
        SNMPMgmt::SmiTableIterator get_ifMauTable();

        /*
             Information about the external jacks attached
             to MAUs attached to an interface.
        */
        SNMPMgmt::SmiTableIterator get_ifJackTable();
    };


    /*
             An entry in the table, containing information
             about a single MAU.
    */
    interface ifMauEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex";

        /*
             This variable uniquely identifies the interface
             to which the MAU described by this entry is
             connected.
        REFERENCE:
            "RFC 2863, ifIndex"

        */
        readonly attribute InterfaceIndexType ifMauIfIndex;

        /*
             This variable uniquely identifies the MAU
             described by this entry from among other MAUs
             connected to the same interface (ifMauIfIndex).
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.1, aMAUID."

        */
        readonly attribute IfMauIndexType ifMauIndex;

        /*
             This object identifies the MAU type.  Values for
             standard IEEE 802.3 MAU types are defined above.
             If the MAU type is unknown, the object identifier
             
             unknownMauType OBJECT IDENTIFIER ::= { 0 0 }
             
             is returned.  Note that unknownMauType is a
             syntactically valid object identifier, and any
             conformant implementation of ASN.1 and the BER
             must be able to generate and recognize this
             value.
             
             This object represents the operational type of
             the MAU, as determined by either (1) the result
             of the auto-negotiation function or (2) if
             auto-negotiation is not enabled or is not
             implemented for this MAU, by the value of the
             object ifMauDefaultType.  In case (2), a set to
             the object ifMauDefaultType will force the MAU
             into the new operating mode.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.2, aMAUType."

        */
        readonly attribute AutonomousTypeType ifMauType;

        /*
             The current state of the MAU.  This object MAY
             
             
             
             be implemented as a read-only object by those
             agents and MAUs that do not implement software
             control of the MAU state.  Some agents may not
             support setting the value of this object to some
             of the enumerated values.
             
             The value other(1) is returned if the MAU is in
             a state other than one of the states 2 through
             6.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             A MAU in the operational(3) state is fully
             functional, operates, and passes signals to its
             attached DTE or repeater port in accordance to
             its specification.
             
             A MAU in standby(4) state forces DI and CI to
             idle and the media transmitter to idle or fault,
             if supported.  Standby(4) mode only applies to
             link type MAUs.  The state of
             ifMauMediaAvailable is unaffected.
             
             A MAU in shutdown(5) state assumes the same
             condition on DI, CI, and the media transmitter
             as though it were powered down or not connected.
             The MAU MAY return other(1) value for the
             ifMauJabberState and ifMauMediaAvailable objects
             when it is in this state.  For an AUI, this
             state will remove power from the AUI.
             
             Setting this variable to the value reset(6)
             resets the MAU in the same manner as a
             power-off, power-on cycle of at least one-half
             second would.  The agent is not required to
             return the value reset (6).
             
             Setting this variable to the value
             operational(3), standby(4), or shutdown(5)
             causes the MAU to assume the respective state
             except that setting a mixing-type MAU or an AUI
             to standby(4) will cause the MAU to enter the
             shutdown state.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.7, aMAUAdminState,
             30.5.1.2.2, acMAUAdminControl, and 30.5.1.2.1,
             acResetMAU."

        */
        attribute IfMauStatusType ifMauStatus;

        /*
             If the MAU is a link or fiber type (FOIRL,
             10BASE-T, 10BASE-F) then this is equivalent to
             the link test fail state/low light function.
             For an AUI or a coax (including broadband) MAU
             this indicates whether or not loopback is
             detected on the DI circuit.  The value of this
             attribute persists between packets for MAU types
             AUI, 10BASE5, 10BASE2, 10BROAD36, and 10BASE-FP.
             
             The value other(1) is returned if the
             mediaAvailable state is not one of 2 through 18.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.  At power-up or following a
             reset, the value of this attribute will be
             unknown for AUI, coax, and 10BASE-FP MAUs.  For
             these MAUs loopback will be tested on each
             transmission during which no collision is
             detected.  If DI is receiving input when DO
             returns to IDL after a transmission and there
             has been no collision during the transmission
             then loopback will be detected.  The value of
             
             
             
             this attribute will only change during
             non-collided transmissions for AUI, coax, and
             10BASE-FP MAUs.
             
             For 100Mbps and 1000Mbps MAUs, the enumerations
             match the states within the respective link
             integrity state diagrams, fig 32-16, 23-12 and
             24-15 of sections 32, 23 and 24 of [IEEE802.3].
             Any MAU which implements management of
             auto-negotiation will map remote fault
             indication to remote fault.
             
             The value available(3) indicates that the link,
             light, or loopback is normal.  The value
             notAvailable(4) indicates link loss, low light,
             or no loopback.
             
             The value remoteFault(5) indicates that a fault
             has been detected at the remote end of the link.
             This value applies to 10BASE-FB, 100BASE-T4 Far
             End Fault Indication and non-specified remote
             faults from a system running auto-negotiation.
             The values remoteJabber(7), remoteLinkLoss(8),
             and remoteTest(9) SHOULD be used instead of
             remoteFault(5) where the reason for remote fault
             is identified in the remote signaling protocol.
             The value invalidSignal(6) indicates that an
             invalid signal has been received from the other
             end of the link.  invalidSignal(6) applies only
             to MAUs of type 10BASE-FB.
             
             Where an IEEE Std 802.3-2002 clause 22 MII
             is present, a logic one in the remote fault bit
             (reference section 22.2.4.2.8 of that document)
             maps to the value remoteFault(5), and a logic
             zero in the link status bit (reference section
             22.2.4.2.10 of that document) maps to the value
             notAvailable(4).  The value notAvailable(4)
             takes precedence over the value remoteFault(5).
             
             Any MAU that implements management of clause 37
             Auto-Negotiation will map the received RF1 and
             RF2 bit values for Offline to offline(10), Link
             Failure to remoteFault(5) and Auto-Negotiation
             Error to autoNegError(11).
             
             For 10 Gb/s, the enumerations map to the states
             within the Reconciliation Sublayer state diagram
             
             
             
             as follows:
               NoFault maps to the enumeration 'available(3)'
               LocalFault maps to the enumeration
                 'notAvailable(4)'
               RemoteFault maps to the enumeration
                 'remoteFault(5)'
             The enumerations 'pmdLinkFault(12)',
             'wisFrameLoss(13)', 'wisSignalLoss(14)',
             'pcsLinkFault(15)', 'excessiveBER(16)', and
             'dxsLinkFault(17)' and 'pxsLinkFault(18)' should
             be used instead of the enumeration
             'notAvailable(4)' where the reason for the local
             fault can be identified through the use of the
             MDIO Interface.  Where multiple reasons for the
             local fault state can be identified only the
             highest precedence error should be reported.
             The precedence in descending order is as
             follows:
                 pxsLinkFault
                 pmdLinkFault
                 wisFrameLoss
                 wisSignalLoss
                 pcsLinkFault
                 excessiveBER
                 dxsLinkFault
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.4, aMediaAvailable."

        */
        readonly attribute IfMauMediaAvailableType ifMauMediaAvailable;

        /*
             A count of the number of times that
             ifMauMediaAvailable for this MAU instance leaves
             the state available(3).
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.5,
             aLoseMediaCounter.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauMediaAvailableStateExits;

        /*
             The value other(1) is returned if the jabber
             state is not 2, 3, or 4.  The agent MUST always
             return other(1) for MAU type dot3MauTypeAUI.
             
             The value unknown(2) is returned when the MAU's
             true state is unknown; for example, when it is
             being initialized.
             
             If the MAU is not jabbering the agent returns
             noJabber(3).  This is the 'normal' state.
             
             If the MAU is in jabber state the agent returns
             the jabbering(4) value.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.6,
             aJabber.jabberFlag."

        */
        readonly attribute IfMauJabberStateType ifMauJabberState;

        /*
             A count of the number of times that
             mauJabberState for this MAU instance enters the
             state jabbering(4). This counter will always
             indicate zero for MAUs of type dot3MauTypeAUI
             and those of speeds above 10Mbps.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.6,
             aJabber.jabberCounter.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauJabberingStateEnters;

        /*
             A count of the number of false carrier events
             
             
             
             during IDLE in 100BASE-X and 1000BASE-X links.
             
             For all other MAU types, this counter will
             always indicate zero. This counter does not
             increment at the symbol rate.
             
             It can increment after a valid carrier
             completion at a maximum rate of once per 100 ms
             for 100BASE-X and once per 10us for 1000BASE-X
             until the next CarrierEvent.
             
             This counter can roll over very quickly.  A
             management station is advised to poll the
             ifMauHCFalseCarriers instead of this counter in
             order to avoid loss of information.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.10, aFalseCarriers.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter32Type ifMauFalseCarriers;

        /*
             This object identifies the default
             administrative baseband MAU type, to be used in
             conjunction with the operational MAU type
             denoted by ifMauType.
             
             The set of possible values for this object is
             the same as the set defined for the ifMauType
             object.
             
             This object represents the
             administratively-configured type of the MAU.  If
             auto-negotiation is not enabled or is not
             implemented for this MAU, the value of this
             object determines the operational type of the
             MAU.  In this case, a set to this object will
             force the MAU into the specified operating mode.
             
             
             
             
             If auto-negotiation is implemented and enabled
             for this MAU, the operational type of the MAU
             is determined by auto-negotiation, and the value
             of this object denotes the type to which the MAU
             will automatically revert if/when
             auto-negotiation is later disabled.
             
             NOTE TO IMPLEMENTORS:  It may be necessary to
             provide for underlying hardware implementations
             which do not follow the exact behavior specified
             above.  In particular, when
             ifMauAutoNegAdminStatus transitions from enabled
             to disabled, the agent implementation MUST
             ensure that the operational type of the MAU (as
             reported by ifMauType) correctly transitions to
             the value specified by this object, rather than
             continuing to operate at the value earlier
             determined by the auto-negotiation function.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.1, aMAUID, and
             22.2.4.1.4."

        */
        attribute AutonomousTypeType ifMauDefaultType;

        /*
             This object indicates whether or not
             auto-negotiation is supported on this MAU.
        */
        readonly attribute TruthValueType ifMauAutoNegSupported;

        /*
             A value that uniquely identifies the set of
             possible IEEE 802.3 types that the MAU could be.
             If auto-negotiation is present on this MAU, this
             object will map to ifMauAutoNegCapabilityBits.
             
             Note that this MAU may be capable of operating
             as a MAU type that is beyond the scope of this
             MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for capabilities that are listed above.
        */
        readonly attribute IfMauTypeListBitsType ifMauTypeListBits;

        /*
             A count of the number of false carrier events
             during IDLE in 100BASE-X and 1000BASE-X links.
             
             For all other MAU types, this counter will
             always indicate zero. This counter does not
             increment at the symbol rate.
             
             This counter is a 64 bit version of
             ifMauFalseCarriers.  Since the 32 bit version of
             this counter can roll over very quickly,
             management stations are advised to poll the
             64 bit version instead in order to avoid loss
             of information.
             
             Discontinuities in the value of this counter can
             occur at re-initialization of the management
             system, and at other times as indicated by the
             value of ifCounterDiscontinuityTime.
        REFERENCE:
            "[IEEE 802.3 Std], 30.5.1.1.10, aFalseCarriers.
             RFC 2863, ifCounterDiscontinuityTime."

        */
        readonly attribute Counter64Type ifMauHCFalseCarriers;
    };


    /*
             An entry in the table, containing information
             about a particular jack.
    */
    interface ifJackEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex ifJackIndex";

        /*
             The jack connector type, as it appears on the
             outside of the system.
        */
        readonly attribute JackTypeType ifJackType;
    };

    interface dot3IfMauAutoNegGroup : SNMPMgmt::SmiEntry {

        /*
             Configuration and status objects for the
             auto-negotiation function of MAUs attached to
             interfaces.
             
             The ifMauAutoNegTable applies to systems in
             which auto-negotiation is supported on one or
             more MAUs attached to interfaces.  Note that if
             auto-negotiation is present and enabled, the
             ifMauType object reflects the result of the
             auto-negotiation function.
        */
        SNMPMgmt::SmiTableIterator get_ifMauAutoNegTable();
    };


    /*
             An entry in the table, containing configuration
             and status information for the auto-negotiation
             function of a particular MAU.
    */
    interface ifMauAutoNegEntry : SNMPMgmt::SmiEntry {

        const string IndexVarList = "ifMauIfIndex ifMauIndex";

        /*
             Setting this object to enabled(1) will cause
             the interface which has the auto-negotiation
             signaling ability to be enabled.
             
             If the value of this object is disabled(2) then
             the interface will act as it would if it had no
             auto-negotiation signaling.  Under these
             conditions, an IEEE 802.3 MAU will immediately
             be forced to the state indicated by the value of
             the object ifMauDefaultType.
             
             NOTE TO IMPLEMENTORS:  When
             ifMauAutoNegAdminStatus transitions from enabled
             to disabled, the agent implementation MUST
             ensure that the operational type of the MAU (as
             reported by ifMauType) correctly transitions to
             the value specified by the ifMauDefaultType
             object, rather than continuing to operate at the
             value earlier determined by the auto-negotiation
             function.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.2,
             
             
             
             aAutoNegAdminState and 30.6.1.2.2,
             acAutoNegAdminControl."

        */
        attribute IfMauAutoNegAdminStatusType ifMauAutoNegAdminStatus;

        /*
             A value indicating whether the remote end of
             the link is using auto-negotiation signaling. It
             takes the value detected(1) if and only if,
             during the previous link negotiation, FLP Bursts
             were received.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.3,
             aAutoNegRemoteSignaling."

        */
        readonly attribute IfMauAutoNegRemoteSignalingType ifMauAutoNegRemoteSignaling;

        /*
             A value indicating the current status of the
             auto-negotiation process.  The enumeration
             parallelDetectFail(5) maps to a failure in
             parallel detection as defined in 28.2.3.1 of
             [IEEE 802.3 Std].
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.4,
             aAutoNegAutoConfig."

        */
        readonly attribute IfMauAutoNegConfigType ifMauAutoNegConfig;

        /*
             If the value of this object is set to
             restart(1) then this will force auto-negotiation
             to begin link renegotiation. If auto-negotiation
             signaling is disabled, a write to this object
             has no effect.
             
             
             
             
             Setting the value of this object to norestart(2)
             has no effect.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.2.1,
             acAutoNegRestartAutoConfig."

        */
        attribute IfMauAutoNegRestartType ifMauAutoNegRestart;

        /*
             A value that uniquely identifies the set of
             capabilities of the local auto-negotiation
             entity.  Note that interfaces that support this
             MIB may have capabilities that extend beyond the
             scope of this MIB.
             
             Note that the local auto-negotiation entity may
             support some capabilities beyond the scope of
             this MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for capabilities that are listed above.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.5,
             aAutoNegLocalTechnologyAbility."

        */
        readonly attribute IfMauAutoNegCapabilityBitsType ifMauAutoNegCapabilityBits;

        /*
             A value that uniquely identifies the set of
             capabilities advertised by the local
             auto-negotiation entity.
             
             Capabilities in this object that are not
             available in ifMauAutoNegCapabilityBits cannot
             be enabled.
             
             Note that the local auto-negotiation entity may
             advertise some capabilities beyond the scope of
             this MIB.  This is indicated by returning the
             bit value bOther in addition to any bit values
             for capabilities that are listed above.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.6,
             aAutoNegAdvertisedTechnologyAbility."

        */
        attribute IfMauAutoNegCapAdvertisedBitsType ifMauAutoNegCapAdvertisedBits;

        /*
             A value that uniquely identifies the set of
             capabilities received from the remote
             auto-negotiation entity.
             Note that interfaces that support this MIB may
             be attached to remote auto-negotiation entities
             which have capabilities beyond the scope of this
             MIB.  This is indicated by returning the bit
             value bOther in addition to any bit values for
             capabilities that are listed above.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.7,
             aAutoNegReceivedTechnologyAbility."

        */
        readonly attribute IfMauAutoNegCapReceivedBitsType ifMauAutoNegCapReceivedBits;

        /*
             A value that identifies any local fault
             indications that this MAU has detected and will
             advertise at the next auto-negotiation
             interaction for 1000Mbps MAUs.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.6,
             aAutoNegAdvertisedTechnologyAbility."

        */
        attribute IfMauAutoNegRemoteFaultAdvertisedType ifMauAutoNegRemoteFaultAdvertised;

        /*
             A value that identifies any fault indications
             received from the far end of a link by the
             local auto-negotiation entity for 1000Mbps
             MAUs.
        REFERENCE:
            "[IEEE 802.3 Std], 30.6.1.1.7,
             aAutoNegReceivedTechnologyAbility."

        */
        readonly attribute IfMauAutoNegRemoteFaultReceivedType ifMauAutoNegRemoteFaultReceived;
    };

    struct RpMauJabberStateVBType {
        string var_name;
        string var_index;
        RpMauJabberStateType rpMauJabberState;
    };

    struct IfMauJabberStateVBType {
        string var_name;
        string var_index;
        IfMauJabberStateType ifMauJabberState;
    };

    struct RpMauJabberTrapType {
        RpMauJabberStateVBType rpMauJabberState;
    };

    struct IfMauJabberTrapType {
        IfMauJabberStateVBType ifMauJabberState;
    };

    /* typed push event communication */
    interface Notifications : SNMPMgmt::Notifications {

        /*
             This trap is sent whenever a managed repeater
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive rpMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE 802.3 Mgt], 30.5.1.3.1, nJabber
             notification."

        */
        void rpMauJabberTrap (
            in CosNaming::Name src_entry_name,
            in CORBA::ScopedName event_type,
            in ASN1_GeneralizedTime event_time,
            in RpMauJabberTrapType notification_info
        );

        /*
             This trap is sent whenever a managed interface
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive ifMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE 802.3 Mgt], 30.5.1.3.1, nJabber
             notification."

        */
        void ifMauJabberTrap (
            in CosNaming::Name src_entry_name,
            in CORBA::ScopedName event_type,
            in ASN1_GeneralizedTime event_time,
            in IfMauJabberTrapType notification_info
        );
    };

    /* typed pull event communication */
    interface PullNotifications : SNMPMgmt::PullNotifications {

        /*
             This trap is sent whenever a managed repeater
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive rpMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE 802.3 Mgt], 30.5.1.3.1, nJabber
             notification."

        */
        void pull_rpMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out RpMauJabberTrapType notification_info
        );
        boolean try_rpMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out RpMauJabberTrapType notification_info
        );

        /*
             This trap is sent whenever a managed interface
             MAU enters the jabber state.
             
             The agent MUST throttle the generation of
             consecutive ifMauJabberTraps so that there is at
             least a five-second gap between them.
        REFERENCE:
            "[IEEE 802.3 Mgt], 30.5.1.3.1, nJabber
             notification."

        */
        void pull_ifMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out IfMauJabberTrapType notification_info
        );
        boolean try_ifMauJabberTrap (
            out CosNaming::Name src_entry_name,
            out CORBA::ScopedName event_type,
            out ASN1_GeneralizedTime event_time,
            out IfMauJabberTrapType notification_info
        );
    };

    interface SmiEntryFactory : SNMPMgmt::GenericFactory {

        rpMauEntry create_rpMauEntry (
            in RpMauGroupIndexType rpMauGroupIndex,
            in RpMauPortIndexType rpMauPortIndex,
            in RpMauIndexType rpMauIndex,
            in RpMauStatusType rpMauStatus
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );

        ifMauEntry create_ifMauEntry (
            in InterfaceIndexType ifMauIfIndex,
            in IfMauIndexType ifMauIndex,
            in IfMauStatusType ifMauStatus,
            in AutonomousTypeType ifMauDefaultType
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );

        ifMauAutoNegEntry create_ifMauAutoNegEntry (
            in InterfaceIndexType ifMauIfIndex,
            in IfMauIndexType ifMauIndex,
            in IfMauAutoNegAdminStatusType ifMauAutoNegAdminStatus,
            in IfMauAutoNegRestartType ifMauAutoNegRestart,
            in IfMauAutoNegCapAdvertisedBitsType ifMauAutoNegCapAdvertisedBits,
            in IfMauAutoNegRemoteFaultAdvertisedType ifMauAutoNegRemoteFaultAdvertised
        ) raises (
            SNMPMgmt::AlreadyExists,
            CosLifeCycle::InvalidCriteria,
            CosLifeCycle::CannotMeetCriteria
        );
    };

};

#endif /* !_MAU_MIB_IDL_ */
